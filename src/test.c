/**
 * C helper file for testing whether `lib.rs` actually compiles
 */
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <net/if.h>
#include <linux/if_tun.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/select.h>
#include <fcntl.h>

#include "test_data.h"
#include <pthread.h>

pthread_mutex_t mutex_ethdriver_buf = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex_client_buf = PTHREAD_MUTEX_INITIALIZER;
void ethdriver_buf_lock(void)
{
  pthread_mutex_lock(&mutex_ethdriver_buf);
}
;
void ethdriver_buf_unlock(void)
{
  pthread_mutex_unlock(&mutex_ethdriver_buf);
}
;
void client_buf_lock(void)
{
  pthread_mutex_lock(&mutex_client_buf);
}
;
void client_buf_unlock(void)
{
  pthread_mutex_unlock(&mutex_client_buf);
}
;

/**
 * Dummy version
 * Normally returns the MAC address of the ethernet driver
 */
void ethdriver_mac(uint8_t *b1, uint8_t *b2, uint8_t *b3, uint8_t *b4,
    uint8_t *b5, uint8_t *b6)
{
  static uint8_t mac[] = { 0x02, 0x00, 0x00, 0x00, 0x00, 0x01 };
  *b1 = mac[0];
  *b2 = mac[1];
  *b3 = mac[2];
  *b4 = mac[3];
  *b5 = mac[4];
  *b6 = mac[5];
}

int ethdriver_tx(int len)
{
  printf("ethdriver_TX: len = %i\n", len);
  return 0;
}

int ethdbuf_len = 0;
int ethdriver_ret = 0;
int ethdriver_rx(int* len)
{
  *len = ethdbuf_len;
  printf("ethdriver_RX: len = %i\n", *len);
  return ethdriver_ret;
}

/**
 * Note: this code is normally autogenerated during seL4 build
 */
struct
{
  char content[65535];
} from_ethdriver_data;

void * ethdriver_buf = (void *) &from_ethdriver_data;

struct
{
  char content[65535];
} to_client_1_data;

void * client_buf_1 = (void *) &to_client_1_data;

void *client_buf(seL4_Word client_id)
{
  switch (client_id) {
    case 1:
      return (void *) client_buf_1;
    default:
      return NULL;
  }
}

void client_emit_1(void)
{
  printf("Client emit 1: calling seL4_signal()\n");
}

void client_emit(unsigned int badge)
{
  if (badge == 1) {
    client_emit_1();
  };
}
/**
 * END OF AUTOGENERATED CODE
 */

bool compare_buffers(uint8_t* origin, uint8_t* destination, int len)
{
  if (len <= 0) {
    return false;
  }
  for (int i = 0; i < len; i++) {
    //printf("idx = %d, origin = %x, destination = %x\n", i, origin[i] , destination[i]);
    if (origin[i] != destination[i]) {
      return false;
    }
  }
  return true;
}

bool send_and_test_packet(uint8_t* data, int data_len)
{
  int len = 0;
  uint8_t* buf = (uint8_t*) client_buf(1);
  for (int i = 0; i <= data_len; i++) {
    buf[i] = data[i];
    len = i;
  }

  printf("client_tx transmitting %u bytes\n", len);
  int returnval = client_tx(len);
  printf("client_tx transmitted %u bytes with return value %i\n", len,
      returnval);

  return compare_buffers(data, (uint8_t*) ethdriver_buf, len);
}

bool receive_and_test_packet(uint8_t* data, int data_len, int* returnval)
{
  int len = 0;
  uint8_t* buf = (uint8_t*) ethdriver_buf;
  for (int i = 0; i <= data_len; i++) {
    buf[i] = data[i];
    len = i;
  }

  ethdbuf_len = len;
  len = 0;
  printf("client_rx receiving\n");
  *returnval = client_rx(&len);
  printf("client_rx received %u bytes with return value %i\n", len, *returnval);

  return compare_buffers(data, (uint8_t*) client_buf(1), len);
}

/**
 * Main program
 */
int main()
{

  printf("\n\nTRANSMIT TEST\n\n");

  bool retval;

  retval = send_and_test_packet(packet_bytes_ping, sizeof(packet_bytes_ping));
  if (retval == false) {
    printf(">>>TX: Testing ping: FAILED\n");
    exit(1);
  } else {
    printf(">>>TX: Testing ping: OK\n");
  }
  printf("\n");

  retval = send_and_test_packet(packet_bytes_arp, sizeof(packet_bytes_arp));
  if (retval == false) {
    printf(">>>TX: Testing ARP: FAILED\n");
    exit(1);
  } else {
    printf(">>>TX: Testing ARP: OK\n");
  }
  printf("\n");

  retval = send_and_test_packet(packet_bytes_multicast_report,
      sizeof(packet_bytes_multicast_report));
  if (retval == true) {
    printf(">>>TX: Testing IPv6: FAILED\n");
    exit(1);
  } else {
    printf(">>>TX: Testing IPv6: OK\n");
  }
  printf("\n");

  retval = send_and_test_packet(packet_bytes_udp_1, sizeof(packet_bytes_udp_1));
  if (retval == false) {
    printf(">>>TX: Testing UDP 1: FAILED\n");
    exit(1);
  } else {
    printf(">>>TX: Testing UDP 1: OK\n");
  }
  printf("\n");

  // fragmented packet
  send_and_test_packet(packet_bytes_udp_frag1, sizeof(packet_bytes_udp_frag1));
  send_and_test_packet(packet_bytes_udp_frag2, sizeof(packet_bytes_udp_frag2));
  retval = send_and_test_packet(packet_bytes_udp_frag3,
      sizeof(packet_bytes_udp_frag3));
  if (retval == false) {
    printf(">>>TX: Testing UDP frag: FAILED\n");
    exit(1);
  } else {
    printf(">>>TX: Testing UDP frag: OK\n");
  }
  printf("\n");


  printf("Testing many fragmented packets without clearing...\n");
  for (int i = 0; i < 20; i++) {
    // fragmented packet
    retval = send_and_test_packet(packet_bytes_udp_frag1,
        sizeof(packet_bytes_udp_frag1));
    send_and_test_packet(packet_bytes_udp_frag2,
        sizeof(packet_bytes_udp_frag2));
    send_and_test_packet(packet_bytes_udp_frag3,
        sizeof(packet_bytes_udp_frag3));
    printf("Round %i OK\n", i);
  }
  printf("Done Testing many fragmented packets without clearing...\n");
  //exit(1);

  printf("\n\n"
      "RECEIVE TEST"
      "\n\n");
  int returnval;

  retval = receive_and_test_packet(packet_bytes_ping, sizeof(packet_bytes_ping),
      &returnval);
  if ((retval == true) && (returnval == 0)) {
    printf(">>>RX: Testing ping: OK\n");
  } else {
    printf(">>>RX: Testing ping: FAILED\n");
    exit(1);
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_arp, sizeof(packet_bytes_arp),
      &returnval);
  if ((retval == true) && (returnval == 0)) {
    printf(">>>RX: Testing ARP: OK\n");
  } else {
    printf(">>>RX: Testing ARP: FAILED\n");
    exit(1);
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_multicast_report,
      sizeof(packet_bytes_multicast_report), &returnval);
  if ((retval == false) && (returnval == -1)) {
    printf(">>>RX: Testing IPv6: OK\n");
  } else {

    printf(">>>RX: Testing IPv6: FAILED\n");
    exit(1);
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_udp_1,
      sizeof(packet_bytes_udp_1), &returnval);
  if ((retval == true) && (returnval == 0)) {
    printf(">>>RX: Testing UDP 1: OK\n");
  } else {
    printf(">>>RX: Testing UDP 1: FAILED\n");
    exit(1);
  }
  printf("\n");

  // fragmented packet
  retval = receive_and_test_packet(packet_bytes_udp_frag1,
      sizeof(packet_bytes_udp_frag1), &returnval);
  if ((retval == false) && (returnval == -1)) {
    printf(">>>RX: Testing UDP frag 1: OK\n");
  } else {
    printf(">>>RX: Testing UDP frag 1: FAILED\n");
    exit(1);
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_udp_frag2,
      sizeof(packet_bytes_udp_frag2), &returnval);
  if ((retval == false) && (returnval == -1)) {
    printf(">>>RX: Testing UDP frag 2: OK\n");
  } else {
    printf(">>>RX: Testing UDP frag 2: FAILED\n");
    exit(1);
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_udp_frag3,
      sizeof(packet_bytes_udp_frag3), &returnval);
  if (retval == true) {  // TODO
    printf(">>>RX: Testing UDP frag: FAILED\n");
    exit(1);
  } else {
    printf(">>>RX: Testing UDP frag: OK\n");
  }
  printf("\n");

  retval = receive_and_test_packet(packet_bytes_udp_1,
      sizeof(packet_bytes_udp_1), &returnval);

  printf(">>>RX: draining data\n");
  int len = 0;
  ethdriver_ret = -1;
  returnval = client_rx(&len);
  returnval = client_rx(&len);
  returnval = client_rx(&len);
  returnval = client_rx(&len);
  ethdriver_ret = 0;
  printf(">>>RX: draining data done\n");
  printf("\n");

  printf("Testing many fragmented packets...\n");
  for (int i = 0; i < 20; i++) {
    // fragmented packet
    retval = receive_and_test_packet(packet_bytes_udp_frag1,
        sizeof(packet_bytes_udp_frag1), &returnval);
    if ((retval == false) && (returnval == -1)) {
      printf(">>>RX: Testing UDP frag 1: OK\n");
    } else {
      printf(">>>RX: Testing UDP frag 1: FAILED\n");
      exit(1);
    }
    printf("\n");

    retval = receive_and_test_packet(packet_bytes_udp_frag2,
        sizeof(packet_bytes_udp_frag2), &returnval);
    if ((retval == false) && (returnval == -1)) {
      printf(">>>RX: Testing UDP frag 2: OK\n");
    } else {
      printf(">>>RX: Testing UDP frag 2: FAILED\n");
      exit(1);
    }
    printf("\n");

    retval = receive_and_test_packet(packet_bytes_udp_frag3,
        sizeof(packet_bytes_udp_frag3), &returnval);
    if (retval == true) {  // TODO
      printf(">>>RX: Testing UDP frag: FAILED\n");
      exit(1);
    } else {
      printf(">>>RX: Testing UDP frag: OK\n");
    }
    printf("\n");

    printf(">>>RX: draining data\n");
    int len = 0;
    ethdriver_ret = -1;
    returnval = client_rx(&len);
    returnval = client_rx(&len);
    returnval = client_rx(&len);
    returnval = client_rx(&len);
    ethdriver_ret = 0;
    printf(">>>RX: draining data done\n");
    printf("\n");

    printf("Round %i OK\n", i);
  }
  printf("Done Testing many fragmented packets...\n");


  printf("Testing many fragmented packets without clearing...\n");
  for (int i = 0; i < 20; i++) {
    // fragmented packet
    retval = receive_and_test_packet(packet_bytes_udp_frag1,
        sizeof(packet_bytes_udp_frag1), &returnval);
    retval = receive_and_test_packet(packet_bytes_udp_frag2,
        sizeof(packet_bytes_udp_frag2), &returnval);
    retval = receive_and_test_packet(packet_bytes_udp_frag3,
        sizeof(packet_bytes_udp_frag3), &returnval);
    printf("Round %i OK\n", i);
  }
  printf("Done Testing many fragmented packets without clearing...\n");

}
